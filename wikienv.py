import time
from typing import Any, Dict, List, Optional, Tuple, Union

import gym
import requests
from bs4 import BeautifulSoup


def clean_str(p: str) -> str:
    return p.encode().decode("unicode-escape").encode("latin1").decode("utf-8")


class textSpace(gym.spaces.Space):
    def contains(self, x: Any) -> bool:
        return isinstance(x, str)


class WikiEnv(gym.Env):
    def __init__(self) -> None:
        super().__init__()
        self.page: Optional[str] = None
        self.obs: Optional[str] = None
        self.lookup_keyword: Optional[str] = None
        self.lookup_list: Optional[List[str]] = None
        self.lookup_cnt: Optional[int] = None
        self.steps: int = 0
        self.answer: Optional[str] = None
        self.observation_space = self.action_space = textSpace()
        self.search_time: float = 0.0
        self.num_searches: int = 0

    def _get_obs(self) -> Optional[str]:
        return self.obs

    def _get_info(self) -> Dict[str, Any]:
        return {"steps": self.steps, "answer": self.answer}

    def reset(
        self,
        seed: Optional[int] = None,
        return_info: bool = False,
        options: Optional[Dict] = None,
    ) -> Union[str, Tuple[str, Dict[str, Any]]]:
        self.obs = ("Interact with Wikipedia using search[], lookup[], and " "finish[].\n")
        self.page = None
        self.lookup_keyword = None
        self.lookup_list = None
        self.lookup_cnt = None
        self.steps = 0
        self.answer = None
        observation = self._get_obs()
        info = self._get_info()
        return (observation, info) if return_info else observation

    def construct_lookup_list(self, keyword: str) -> List[str]:
        if self.page is None:
            return []
        paragraphs = self.page.split("\n")
        paragraphs = [p.strip() for p in paragraphs if p.strip()]
        sentences = []
        for p in paragraphs:
            sentences += p.split(". ")
        sentences = [s.strip() + "." for s in sentences if s.strip()]
        return [p for p in sentences if keyword.lower() in p.lower()]

    @staticmethod
    def get_page_obs(page: str) -> str:
        paragraphs = page.split("\n")
        paragraphs = [p.strip() for p in paragraphs if p.strip()]
        sentences = []
        for p in paragraphs:
            sentences += p.split(". ")
        sentences = [s.strip() + "." for s in sentences if s.strip()]
        return " ".join(sentences[:5])

    def search_step(self, entity: str) -> None:
        entity_ = entity.replace(" ", "+")
        search_url = f"https://en.wikipedia.org/w/index.php?search={entity_}"
        old_time = time.time()
        response_text = requests.get(search_url).text
        self.search_time += time.time() - old_time
        self.num_searches += 1
        soup = BeautifulSoup(response_text, features="html.parser")
        result_divs = soup.find_all("div", {"class": "mw-search-result-heading"})
        if result_divs:
            self.result_titles = [clean_str(div.get_text().strip()) for div in result_divs]
            self.obs = f"Could not find {entity}. Similar: {self.result_titles[:5]}."
        else:
            page = [p.get_text().strip() for p in soup.find_all("p") + soup.find_all("ul")]
            if any("may refer to:" in p for p in page):
                self.search_step("[" + entity + "]")
            else:
                self.page = ""
                for p in page:
                    if len(p.split(" ")) > 2:
                        self.page += clean_str(p)
                        if not p.endswith("\n"):
                            self.page += "\n"
                self.obs = self.get_page_obs(self.page)
                self.lookup_keyword = self.lookup_list = self.lookup_cnt = None

    def step(self, action: Any) -> Tuple[str, float, bool, Dict[str, Any]]:
        reward = 0.0
        done = False
        action = str(action).strip()
        if self.answer is not None:
            done = True
            return self.obs or "", reward, done, self._get_info()
        if action.startswith("search[") and action.endswith("]"):
            entity = action[len("search[") : -1]
            self.search_step(entity)
        elif action.startswith("lookup[") and action.endswith("]"):
            keyword = action[len("lookup[") : -1]
            if self.lookup_keyword != keyword:
                self.lookup_keyword = keyword
                self.lookup_list = self.construct_lookup_list(keyword)
                self.lookup_cnt = 0
            if self.lookup_cnt >= len(self.lookup_list):
                self.obs = "No more results.\n"
            else:
                self.obs = f"(Result {self.lookup_cnt + 1} / {len(self.lookup_list)}) " + self.lookup_list[self.lookup_cnt]
                self.lookup_cnt += 1
        elif action.startswith("finish[") and action.endswith("]"):
            answer = action[len("finish[") : -1]
            self.answer = answer
            done = True
            self.obs = f"Episode finished, reward = {reward}\n"
        elif action.startswith("think[") and action.endswith("]"):
            self.obs = "Nice thought."
        else:
            self.obs = f"Invalid action: {action}"
        self.steps += 1
        return self.obs or "", reward, done, self._get_info()

    def get_time_info(self) -> Dict[str, Any]:
        speed = self.search_time / self.num_searches if self.num_searches else 0.0
        return {"call_speed": speed, "call_time": self.search_time, "num_calls": self.num_searches}
